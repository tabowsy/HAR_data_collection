# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'my_gui.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import sys
from PyQt5.QtWidgets import*
from numpy import mean
from numpy import std
from numpy import dstack
from pandas import read_csv
import numpy as np
import random
import seaborn as sns
import threading
import pandas as pd
from matplotlib import pyplot as plt
#import tensorflow as tf
import matplotlib
matplotlib.use('Qt5Agg')
from PyQt5.QtCore import QThread
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import time

import serial

import os, sys
import asyncio
import platform
from datetime import datetime
from typing import Callable, Any





start_flag = 0
activity = 'Walking'
class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(600, 600)
        self.label = QtWidgets.QLabel(Form)
        self.label.setGeometry(QtCore.QRect(260, 20, 150, 21))
        self.label.setObjectName("label")
        self.layoutWidget1 = QtWidgets.QWidget(Form)
        self.layoutWidget1.setGeometry(QtCore.QRect(150, 500, 321, 71))
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.layoutWidget1)
        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.pushButton_2 = QtWidgets.QPushButton(self.layoutWidget1)
        self.pushButton_2.setObjectName("pushButton_2")
        self.gridLayout_2.addWidget(self.pushButton_2, 100, 100, 1, 1)
        self.pushButton = QtWidgets.QPushButton(self.layoutWidget1)
        self.pushButton.setObjectName("pushButton")
        self.gridLayout_2.addWidget(self.pushButton, 100, 101, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.label.setText(_translate("Form", "Recognition result:"))
        self.pushButton_2.setText(_translate("Form", "Start"))
        self.pushButton.setText(_translate("Form", "Finish"))

class AppWindow(QDialog): 
    def __init__(self):
        super().__init__()
        self.activity = 'Walking'
        
        self.ui = Ui_Form() 
        self.ui.setupUi(self)
        self.ui.pushButton.clicked.connect(self.receive_finish)
        self.ui.pushButton_2.clicked.connect(self.receive_start)


        self.chart2 = Canvas2(self)
        self.chart2.move(55,70)

        self.show() 
    def onClicked(self):
        radioBtn = self.sender()

        if radioBtn.isChecked():
            print(radioBtn.text())
            self.activity = radioBtn.text()

    def receive_start(self):
        time.sleep(1)
        self.chart2.receive_data()

    def receive_finish(self):
        sender = self.sender() 
        print(sender.text() + ' 按钮被按下')  
        app = QApplication.instance()  
        # 退出应用程序
        app.quit()

        sys.exit(app.exec_())
        
    def plot_data(self):
        print(self.chart)
        self.chart.plot(int(self.ui.textEdit.toPlainText()),self.activity)




class Canvas2(FigureCanvas,threading.Thread):  # 畫布二 自行成一個執行續。
    def __init__(self, parent):
        
        super(threading.Thread, self).__init__()
        self.fig = Figure(figsize=(5, 4), dpi=100)
        super(FigureCanvas, self).__init__(self.fig)
        self.ax = self.fig.add_subplot(111)
        self.setParent(parent)
        self.datas = 0
        self.serial = serial.Serial(port='/dev/tty.BT_07', baudrate=38400, timeout=0, parity=serial.PARITY_NONE, stopbits=1)
        self.result = []
        self.label_class = ['Stairs','Jogging','Sitting','Standing','Stairs','Walking']
        # Create the event loop.
        self.loop = asyncio.get_event_loop()

        self.t = threading.Thread(target = self.plot2)

    def plot2(self):
        self.serial.bytesize = serial.EIGHTBITS #number of bits per bytes   #hc05
        self.serial.parity = serial.PARITY_NONE #set parity check           #hc05
        self.serial.stopbits = serial.STOPBITS_ONE #number of stop bits     #hc05
        data = []
        new_data = []
        count = 0
        sec = 5
        flag = False
        result = []
        
        '''READER LOOP'''
        self.result = []
        print('start to read')

        while (1):
            a = b''
            endLine = False
            if flag == False:
                self.serial.write(b'egg')   #hc-05
                self.serial.write(b"\r\n")  #hc-05
                flag = True
            else:
                while(1):
                    
                    c = self.serial.read() # 1ms  hc-05
                    #c = self.connection.rx_data  
                    # print(c)
                    count += 1
                    if(c != b''):
                        #print(c)
                        count = 0
                        if(c == b'\xff' and endLine == False):
                            endLine = True
                        elif (c == b'\xff' and endLine == True):
                            break
                        elif endLine == True:
                            a += b'\xff'
                            a += c
                            endLine = False
                        else:
                            a += c
                            endLine = False 
                #if(count > 1000 * sec):
                #    break
                if( len(a) == 15):
                    x = a[4] + (a[6] << 8 | a[5]) * 0.001
                    y = a[8] + (a[10] << 8 | a[9]) * 0.001
                    z = a[12] + (a[14] << 8 | a[13]) * 0.001  
                    print("data:{} X:{}{} Y:{}{} Z:{}{}".format(
                        (a[1] << 8 | a[2]),
                        '+' if a[3] else '-', 
                        x,
                        '+' if a[7] else '-', 
                        y,
                        '+' if a[11] else '-', 
                        z
                        )   
                    )
                    #print(s)
                    if a[3] == 0:
                        x = -1*x
                    if a[7] == 0:
                        y = -1*y
                    if a[11] == 0:
                        z = -1*z    
                    result.append([x,y,z])      
                    #serialPort.write(b"\r\n")
                if ((a[1] <<8 | a[2]) >= 50):
                    while(1):
                        predict = self.serial.read() # 1ms
                        if predict != b'':
                            print(predict)
                            new_data2 = np.array(result)
                            #new_data3 = np.delete(new_data2, 0 ,axis = 1)
                            self.ax.clear()
                            self.ax.grid()
                            print(new_data2.shape[0])
                            t = np.arange(0.0, new_data2.shape[0], 1)
                            x = np.arange(0,(new_data2.shape[0]),1)
                            # print(data,'after---------------')
                            data = np.transpose(new_data2)
                            try:
                                self.ax.plot(x, data[0][0:len(t)])
                                self.ax.plot(x, data[1][0:len(t)])
                                self.ax.plot(x, data[2][0:len(t)])
                                self.ax.legend(['x-acc','y-acc','z-acc'])
                                print('plot arc here')
                                self.ax.set(xlabel='time (s)', ylabel='voltage (mV)',title = self.label_class[int(predict.hex())])
                            except:
                                break
                            self.fig.canvas.draw_idle() 
                            result = []
                            new_data2 = []
                            flag = False
                            break
                    
    def receive_data(self):  
        self.t.start()

    def close_bluetooth(self):
        #self.serial.close()
        pass


if __name__ == '__main__':
    from multiprocessing import Process

    app = QApplication(sys.argv)
    w = AppWindow()
    w.show()
    #serialPort.close()
    sys.exit(app.exec_())
    
